# Advanced C++

## Compiler generated functions

### What functions are generated by the compiler?

The C++ compiler will implicitly declare and define certain member functions for a class if the programmer does not explicitly provide them. These include:

```c++
class X
{
public:
    X(); // default constructor
    X( X const& ); // copy constructor
    X& operator=( X const& ); // copy assignment operator
    X&( X&& ) noexcept; // move constructor
    X& operator=( X&& ) noexcept; // move assignment operator
    ~X(); // destructor
};
```

These functions are collectively referred to as "special member functions". They are only implicitly declared if they are needed (that is, if there is code that needs to call them), and if the declaration would not be ill-formed (for example, if a class has a const or reference member, the compiler cannot generate an assignment operator).

By using `=default;` in the function declaration, you can instruct the compiler to generate the default version of any of these functions.

### Default Constructor

The compiler generates a default constructor automatically if:
- No other constructor is explicitly declared in the class.
- All data members (and base classes) are default-constructable.
> If a class has a member variable that is not default constructible (e.g., a reference or a class with no default constructor), the compiler won't be able to generate a default constructor.
This compiler-generated default constructor is known as an implicitly-declared default constructor. It initializes each non-static data member of the class as follows:
- If the member is of class type, by recursively invoking its default constructor.
- If the member is an array, each element is direct-initialized (with curly-brace notation `{}`) or default-initialized.
- Otherwise, nothing is done. Built-in types, if they are not explicitly initialized, they will be left default initialized - uninitialized (which means they could contain any value).

The default constructor's task is to initialize all data members. If a default constructor is not defined, the compiler still attempts to provide one.

### Initialization
C++ provides multiple ways for initialization:

```c++
std::string s; // default initialization: default constructor is called, built-in types will have indeterminate values
std::string s{}; // value initialization: initializes to a predictable value, built-in types will be zero-initialized
std::string s{"hi"}; // direct initialization: initializes with the provided value, directly calls the relevant constructor
std::string s = "hi"; // copy initialization: involves an extra copy operation, 
std::string s{'h','i'}; // list initialization
char a[3] = {'h','i'}; // aggregate initialization
char& c = a[0]; // reference initialization
```

### Default vs Value Initialization

**Default Initialization** does not initialize non-class variables if no default constructor is implemented. For implemented default constructors, it will call the default constructor.

**Value Initialization** results in zero initialization and default initialization if there's no default constructor, or a call to the default constructor if it's implemented.

When you use empty braces `{}` to initialize an object, it gets value initialized, which means:
- If the class has a user-declared default constructor, it is called.
- If the class doesn't have a user-declared default constructor but has a trivial default constructor, the object is zero-initialized, which means that the object is initialized with zeros, i.e., integer is initialized as `0`, pointer as `nullptr`, etc.
- If the class neither has a user-declared default constructor nor a trivial default constructor, the object is default-initialized, which means no initialization happens for non-static non-POD types.

Value initialization is generally preferable to default initialization.

### Member Data Initialization
Consider this class:

```c++
#include <vector>

class X {
    int i;
    std::vector<double> v;
    double* p;
};

int main() {
    X x1; // default initialization
    X x2{}; // value initialization
}
```

| variable | x1 default initialization | x2 value initialization |
| -------- | ------------------------- | ----------------------- |
| i        | uninitialized             | initialized to 0        |
| v        | default initialized       | default initialized     |
| p        | uninitialized             | initialized to nullptr  |

```c++
#include <vector>

class X {
    int i;
    std::vector<double> v;
    double* p;
public:
    X() {} // implement default constructor explicitly
};
```

```c++
#include <vector>

class X {
    int i;
    std::vector<double> v;
    double* p;
public:
    X() = default; // let compiler generate the default constructor
}
```

### Member Data Initialization with Constant Values

**Assignment during construction**: The constructor first default-initializes the members and then assigns them new values. Suitable for simple types but may cause overhead for complex types due to temporary object creation.

```c++
class X {
    int i;
    std::vector<double> v;
    double* p;
public:
    X() {
        i=22;
        p=nullptr;
    }
};
```

**Constructor initializer list**: Directly initializes members avoiding temporary object creation. Necessary for const and reference members but order of initialization can be misleading.

```c++
class X {
    int i;
    std::vector<double> v;
    double* p;
public:
    X() :
    i{22},
    p{nullptr}
    { }
};
```

**In-class member initializers**: Specifies default values for members at declaration. Simplifies code and useful when no constructor is needed. Default values are used when constructor does not specify them.

```c++
class X {
    int i{22};
    std::vector<double> v;
    double* p{nullptr};
public:
    X() = default;
};
```

### Copy â€“ constructor and assignment operator

The compiler automatically generates a copy constructor and a copy assignment operator if:
- They are not explicitly defined by the user.
- All data members and base classes are copyable.
- No move constructor or move assignment operator are explicitly defined or deleted.

The role of both the copy constructor and the copy assignment operator is to copy data from one object to another.
- The copy constructor is responsible for defining how an object should be copied during initialization.
- The copy assignment operator defines how an object should be copied to an already existing object.

Although compiler-generated (synthesized) copy functions do perform a copy of the object, it is a shallow copy. They simply copy the member-wise data, which works fine for primitive types but can lead to issues for classes with dynamic memory or complex resources.

Therefore, if a class has members that point to heap-allocated data, the default behavior may lead to problems (like shallow copying). For such classes, it is important to provide a user-defined copy constructor and copy assignment operator that correctly performs a deep copy, ensuring each object has its own copy of the heap-allocated data.

```cpp
class X {
    int i{22};
    double* p{nullptr};
public:
    X() = default;
    X(const X& other) : i{other.i}, p{other.p} {}
    X& operator=(const X& other) {
        if (this == &other) return *this;
        i = other.i;
        p = other.p;
        return *this;
    }
};
```

### Destructor
- The destructor is automatically generated by the compiler if it is not explicitly defined.
- The task of the destructor is to clean up and release all resources.
- The destructor calls the destructors of all non-fundamental data members.
- Prefer the (default) generated destructor to an empty destructor, unless you need to manage resources manually (e.g., deallocation of dynamic memory, closing files, releasing network or database connections, etc.).
- The compiler-generated destructor is sufficient if all data members of your class are of a type that manages its own resources, like standard library containers or smart pointers.

### Managing Resources in Destructor
- If a class has data members that manage resources which are not automatically released, then a user-defined destructor is necessary to correctly release these resources and avoid resource leaks.
- In modern C++, many resource management tasks are handled by RAII (Resource Acquisition Is Initialization) objects, like smart pointers or container classes. They automatically release their resources when they go out of scope. In this case, the default destructor is often enough.
- Be aware that a user-defined destructor prevents the compiler from automatically generating move operations. If you need them, you'll have to implement them yourself.

### Value categories
- **lvalue**: an expression that identifies a non-temporary object or a non-member function
  - Examples: variables, function names, `++i`, `*p`, `a[i]`.
- **prvalue (pure rvalue)**: a rvalue that isn't an xvalue
  - Examples: `nullptr`, `42`, `i++`, `a+b`, `this`, `std::string("Hello")`
- **xvalue (expiring value)**: a value that is both an rvalue and a glvalue
  - Examples: `a.m` (if `a` is rvalue and `m` non-static), `std::move(a)`
- **glvalue (generalized lvalue)**: a value category that includes both lvalues and xvalues
  - Examples: all lvalue and xvalue expressions
- **rvalue**: an expression that identifies a temporary object or a prvalue
  - Examples: `42`, `i++`, `a+b`.

**lvalue**, **xvalue** and **prvalue** can be classified into movable and not movable categories, also into identity and no identity.
- An object referred to by an **lvalue** can have its identity moved if the **lvalue** is cast to an **xvalue** with `std::move`.
- A **prvalue** does not have a persistent identity beyond the expression it appears in, and is movable by nature (its resources can be transferred to another object).
- An **xvalue** is an "expiring" object which is typically the result of moving from an **lvalue**. It also doesn't have a persistent identity.

### Rvalue references
- rvalue reference declarator: `&&`
- There are no references to references.
- Extension of lifetime of temporary objects.
- Allows modification of object.
- Must be initialized at declaration.
- Example: `void f(int&& x);`

```cpp
# include <iostream>
# include <utility>

void g(int& i) { std::cout<<"g(int& )\n"; }
void g(int&& i) { std::cout<<"g(int&&)\n"; }
void f(int& i) { std::cout<<"f(int& ) -> "; g(i); }
void f(int&& i) { std::cout<<"f(int&&) -> "; g(i); }

int main() {
    int i=1;
    f(++i);
    f(i++);
}

// What is printed?
// f(int& ) -> g(int& ) and f(int&&) -> g(int& )
```

### Forwarding

- `std::forward<T>` (defined in `<utility>`)
- Forward rvalues as rvalues
- Forward lvalues as lvalues or rvalues depending on template parameter (see universal reference)

```cpp
#include <iostream>
#include <utility>

void g(int& i) { std::cout<<"g(int& )\n"; }
void g(int&& i) { std::cout<<"g(int&&)\n"; }
void f(int& i) { std::cout<<"f(int& ) -> "; g(i); }
void f(int&& i) { std::cout<<"f(int&&) -> "; g(std::forward<int&&>(i)); }

int main() {
    int i=1;
    f(++i);
    f(i++);
}

// What is printed?
// f(int& ) -> g(int& )
// f(int&&) -> g(int&&)
```

### Move â€“ constructor and assignment operator

- `std::move` (defined in `<utility>`)
- Unconditional static cast to rvalue reference
- Allowing the efficient transfer of resources

The move constructor and move assignment operator are automatically generated by the compiler if:
- They are not explicitly defined, and
- If all data members (and base classes) are movable or copyable, and
- If no copy constructor, copy assignment operator and destructor are explicitly defined.

The task of the move constructor and move assignment operator is to steal the content of another object.
The passed object should be valid but undefined after move operation.

```c++
#include <utility>

class X {
    int i{22};
    double* p{nullptr};
public:
    X() = default;
    X(X && other) : i{std::move(other.i)}, p{std::move(other.p)} { other.p = nullptr; }
    X& operator=(X && other) {
        if (this == &other) return *this;
        i=std::move(other.i);
        p=std::move(other.p);
        other.p = nullptr;
        return *this;
    }
};

int main() {
    X x1{};
    X x2 = std::move(x1);
    x1 = std::move(x2);
}
```

### Rule of Five
- It is a best practice guideline.
- When any of the five is treated/implemented:
    - Copy constructor
    - Copy assignment operator
    - Move constructor
    - Move assignment operator
    - Destructor
- All of them should be treated.
- Make intention explicit by use of `=default` and `=delete`.

```cpp
#include <utility>

class X
{
    int i{22};
    double *p{nullptr};

public:
    X() = default;
    X(X const&) = default;
    X& operator=(X const&) = default;
    X(X&&) = default;
    X& operator=(X&&) = default;
    ~X() = default;
};

int main()
{
    X x1{}; 
    X x2 = x1;
    x1 = x2;
    X x3 = std::move(x1);
    x1 = std::move(x3);
}
```

### Rule of Five -> Rule of Zero

This section transitions from the Rule of Five to the Rule of Zero. To clarify, the Rule of Zero is the ideal practice in modern C++ programming. It suggests that you should strive to use resource management types that handle these functions automatically, avoiding the need to define them manually in your class. When this cannot be applied, then the Rule of Five comes as a fallback, which states that if you define or delete any default function, then define or delete them all.

### Rule of Zero

```cpp
#include <utility>

class X {
    int i{22};
    double* p{nullptr};
public:
};

int main() {
    X x1{};
    X x2 = x1;
    x1 = x2;
    X x3 = std::move(x1);
    x1 = std::move(x3);
}
```

### Parameter and return values

**Return value optimization**
- Also called: copy elision (in std: \[class.copy.elision\])
- If the return statement has the same type of a returned prvalue
- Objects are constructed directly in the storage where they would be copied/moved to
- The copy/move constructor is not called even if there are side-effects

**Return value optimization**

In these examples, return value optimization (RVO) is demonstrated. RVO is a compiler optimization technique that eliminates the temporary object created to hold a function's return value. The examples show how RVO works and how it affects the order and number of constructor and destructor calls.

```cpp
# include <iostream>

using std::cout;

class X {
public:
    X() { cout << "X() -> "; }
    X(X const&) { cout << "X(X const&) -> ";}
    X& operator=(X const&) { cout << "operator=(X const&) -> "; return *this; }
    ~X() { cout << "~X()\n"; }
};

int main () {
    X x{};
}

// What is printed? 
// X() -> ~X()
```


```c++
# include <iostream>

using std::cout;

class X {
public:
    X() { cout << "X() -> "; }
    X(X const&) { cout << "X(X const&) -> ";}
    X& operator=(X const&) { cout << "operator=(X const&) -> "; return *this; }
    ~X() { cout << "~X()\n"; }
};

X make_X() { return X{}; }

int main () {
    X x{};
    x = make_X();
}

// What is printed?
// X() -> X() -> operator=(X const&) -> ~X()
// ~X()
```

```c++
#include <iostream>

using std::cout;

class X {
public:
    X() { cout << "X() -> "; }
    X(X const&) { cout << "X(X const&) -> ";}
    X& operator=(X const&) { cout << "operator=(X const&) -> "; return *this; }
    ~X() { cout << "~X()\n"; }
};

X make_X() { return X{}; }

int main () {
    X x = make_X();
}

// What is printed?
// X() -> ~X()
```

### Take aways
- value initialization > default initialization
- Prefer using `=default` to implementing an empty default constructor.
- in-class initializer > member initializer > member assignment
- Use member initializer in order of data members.
- Prefer move to copy, if applicable.
- Rule of Zero > Rule of Five >> No Rule
- Be aware of return value optimization.

## Resource management

### Resources
Resources must be acquired and released/disposed explicitly.

Examples for resource types:

| Resource | Acquisition | Disposal |
| -------- | ----------- | -------- |
| memory   | new         | delete   |
| files    | fopen       | fclose   |
| mutex    | lock        | unlock   |
| thread   | create      | join     |

Common issues that might occur during resource management:
  - leak (losing the handle to a resource)
  - double disposal
  - usage after disposal

### Resources â€“ Examples
Leak
```cpp
int main()
{
    int *x = new int{};
    x = nullptr;
}
```

Double disposal
```cpp
int main()
{
    int *x = new int{};
    delete x;
    delete x;
}
```

Usage after disposal
```cpp
int main()
{
    int *x = new int{};
    delete x;
    *x = 1;
}
```

### Resources â€“ larger memory leak example
How can we avoid a memory leak here?
```cpp
bool bad_code() {
    int* i = new int{};
    std::cin >> *i;
    do_something(i);
    std::cout << *i << std::endl;
    return true;
}
```
Call delete to free the dynamically allocated memory.

Solution
```cpp
bool bad_code() {
    int* i = new int{};
    std::cin >> *i;
    do_something(i);
    std::cout << *i << std::endl;
    delete i;
    return true;
}
```
Assume we want to have an early return statement for some reason.

How can we improve the given function?
```cpp
bool bad_code() {
    int* i = new int{};
    std::cin >> *i;
    do_something(i);
    if (*i == 22) {
        return false;
    }
    std::cout << *i << std::endl;
    delete i;
    return true;
}
```
Again, call delete to free the dynamically allocated memory before returning.

Solution:
```cpp
bool bad_code() {
    int* i = new int{};
    std::cin >> *i;
    do_something(i);
    if (*i == 22) {
        delete i;
        return false;
    }
    std::cout << *i << std::endl;
    delete i;
    return true;
}
```
But what if do something throws an exception?

Catch it and call delete to free the dynamically allocated memory.

Solution:
```cpp
bool bad_code() {
    int* i = new int{};
    std::cin >> *i;
    try {
        do_something(i);
    } catch (...) { 
        std::cout << "exception\n"; 
        delete i; 
        throw; 
    }
    if (*i == 22) {
        delete i;
        return false;
    }
    std::cout << *i << std::endl;
    delete i;
    return true;
}
```
Can we do better, e.g. binding the resource to the lifetime of an object?

### Object lifetime
Object from C++ std [basic.types] (8)
- An object type is a (possibly cv-qualified) type that is not a function type, not a reference type, and not cv void.
    - construction order
      - base classes (first to last)
      - data members (in declaration order)
      - constructor body
    - destruction order
      - reverse of construction order (due to stack memory)
- Call of the destructor from C++ std [class.dtor] (14.3)
    - A destructor is invoked implicitly
        - [...] for a constructed object with automatic storage duration [i.e., not thread local or static] when the block in which an object is created exits, [...]

Lifetime begin and end from C++ std [basic.life]
- The lifetime of an object of type T begins when:
    - storage with the proper alignment and size for type T is obtained, and
    - its initialization (if any) is complete (including vacuous initialization), [...]
- The lifetime of an object o of type T ends when:
    - if T is a non-class type, the object is destroyed, or
    - if T is a class type, the destructor call starts, or
    - the storage which the object occupies is released, or is reused by an object that is not nested within o.

```cpp
# include <iostream>
struct A {
    static int inst;
    A(int i) { std::cout << " A()" << inst << "\n"; if(inst>=i) throw "error"; inst++; }
    ~A() { std::cout << "~A()" << --inst << "\n"; }
};
int A::inst=0;
struct X {
    A _a, _b;
    X(int i) : _a{i}, _b{i} { std::cout << " X()\n"; }
    ~X() { std::cout << "~X()\n"; }
};
int main(int argc, char* argv[]) {
    int i=(argc>1?atoi(argv[1]):42);
    X x{i};
}

// What is printed?
// ./a.out : A()0 A()1 X() ~X() ~A()1 ~A()0
// ./a.out 1 : A()0 A()1 terminate called after throwing
```

```cpp
# include <iostream>
struct A {
    static int inst;
    A(int i) { std::cout << " A()" << inst << "\n"; if(inst>=i) throw "error"; inst++; }
    ~A() { std::cout << "~A()" << --inst << "\n"; }
};
int A::inst=0;
struct X {
    A _a, _b;
    X(int i) : _a{i}, _b{i} { std::cout << " X()\n"; }
    ~X() { std::cout << "~X()\n"; }
};
int main(int argc, char* argv[]) {
    int i=(argc>1?atoi(argv[1]):42);
    try {
        X x{i};
    } catch (...) {}
}

// What is printed?
// ./a.out 1 : A()0 A()1 ~A()0
```

```cpp
# include <iostream>
struct A {
    static int inst;
    A(int i) { std::cout << " A()" << inst << "\n"; if(inst>=i) throw "error"; inst++; }
    ~A() { std::cout << "~A()" << --inst << "\n"; }
};
int A::inst=0;
struct X {
    A *_a, *_b;
    X(int i) : _a{new A{i}}, _b{new A{i}} { std::cout << " X()\n"; }
    ~X() { std::cout << "~X()\n"; delete _a; delete _b; }
};
int main(int argc, char* argv[]) {
    int i=(argc>1?atoi(argv[1]):42);
    try {
        X x{i};
    } catch (...) {}
}

// What is printed?
// ./a.out 1 : A()0 A()1 leak
```

### Single responsibility principle
Why do we have a leak in the previous example?
- Acquisition of the first resource _a was successful.
- Acquisition of the second resource _b failed (exception).
- â‡’ Construction of x failed.
- A destructor is invoked implicitly for a constructed object [...]
- â‡’ Resource _a is never disposed.
- If class X would only manage a single resource, no leak can occur.

This is known as the **Single responsibility principle (SRP)**.

### RAII
**Resource acquisition is initialization**
- One resource should be managed by one object.
- If acquisition fails, the constructor throws an exception and thus the object never exists.
- If acquisition succeeds, the resource is linked to the object.
- The destructor of an object is called if its lifetime ends.
- The destructor should dispose the resource.

Does RAII solve the common issues that might occur with resource management?
- leak (losing the handle to a resource)
- double disposal
- usage after disposal

### Resource acquisition is initialization = No naked new!

### RAII â€“ Examples

RAII for dynamic memory
```cpp
bool bad_code() {
    int* i = new int{};
    std::cin >> *i;
    try {
        do_something(i);
    } catch (...) { std::cout << "exception\n"; delete i; throw; }
    if (*i == 22) {
        delete i;
        return false;
    }
    std::cout << *i << std::endl;
    delete i;
    return true;
}
```

std::vector
```cpp
# include <vector>
void do_something() {
    std::vector<double> v(22);
    // Early returns are allowed.
    // Exceptions are okay.
    // Since the resource (dynamic memory) is bound to the object v,
    // it's destructor (free memory) will be called at the end of v's lifetime.
    return;
} // end of v's object lifetime
// no leak possible
// no double disposal
// no usage after disposal
int main() {
    do_something();
}
```

std::ofstream
```cpp
# include <fstream>
void do_something() {
    std::ofstream file("test.txt");
    // Early returns are allowed.
    // Exceptions are okay.
    // Since the resource (file) is bound to the object file,
    // it's destructor (close file) will be called at the end of file's lifetime.
    return;
} // end of file's object lifetime
// no leak possible
// no double disposal
// no usage after disposal
int main() {
    do_something();
}
```

### Smart pointers
- Smart pointers are objects that apply RAII by storing a pointer to an object allocated on the heap.
- Wrapper around raw pointer
- Behavior is like raw C++ pointer, due to overloading
  - operator*()
  - operator->()
  - operator[](int)
- Polymorphism is available
- Releasing of the dynamic memory in the destructor of the object
- Unique and shared pointer in standard since C++11

### Smart pointers â€“ unique pointers
Unique-ownership pointers from C++ std [unique.ptr]

A unique pointer is an object that owns another object and manages that other object through a
pointer. More precisely, a unique pointer is an object u that stores a pointer to a second object p and
will dispose of p when u is itself destroyed (e.g., when leaving block scope). In this context, u is said
to own p.

- Exclusive ownership
- Movable but not copyable
- Useful for factory functions
- std::unique_ptr (defined in <memory>)
- STL version has no performance overhead compared to raw pointer

```cpp
#include <iostream>
#include <memory>

struct X {
    X() { std::cout << "X\n"; }
    ~X() { std::cout << "~X\n"; }
};

void f(std::unique_ptr<X> const& x) { std::cout << "f\n"; }
void g(std::unique_ptr<X> x) { std::cout << "g\n"; }

int main() {
    std::unique_ptr<X> x(new X{});
    f(x);
    g(std::move(x));
    std::cout << "end of main\n";
}

// Does it compile? If yes, what is printed?
// X f g ~X end of main
```

### Smart pointers â€“ shared pointers
Shared-ownership pointers from C++ std [util.smartptr.shared]

The shared ptr class template stores a pointer, usually obtained via new. shared ptr implements
semantics of shared ownership; the last remaining owner of the pointer is responsible for destroying
the object, or otherwise releasing the resources associated with the stored pointer.

- shared ownership
- copyable and movable
- std::shared_ptr (defined in <memory>)
- be careful with shared pointers (memory leaks are still possible)
- shared pointer is twice the size of a raw pointer

```cpp
#include <iostream>
#include <memory>

struct X {
    X() { std::cout << "X\n"; }
    ~X() { std::cout << "~X\n"; }
};

void f(std::shared_ptr<X> x) { std::cout << "f\n"; }

int main() {
    std::shared_ptr<X> x1(new X{}), x2{x1};
    std::cout << "use_cnt: " << x1.use_count() << std::endl;
    f(std::move(x1));
    std::cout << "use_cnt: " << x1.use_count() << std::endl;
    std::cout << "use_cnt: " << x2.use_count() << std::endl;
    std::cout << "end of main\n";
}
```

### Smart pointer â€“ make shared and make unique
- Shared pointers can be implemented more efficiently by only allocating a single memory block.
- `std::make_shared<T>`
- `std::make_shared<T>(args)` forwards args to constructor of class T.
- This would also avoid conflicts with the SRP (two allocations in constructor).
- Furthermore, the following code might leak:
```cpp
try { 
    f(std::shared_ptr<X>(new X{}), do_something(i)); 
}
```

if the execution order is `new X{}`, `do_something(i)`, `std::shared_ptr<X>(...)`.
- The same is true for `std::unique_ptr`.
- Restrictions of execution order were introduced in C++17.
- Nevertheless, make use of `std::make_shared<T>` and `std::make_unique<T>`

### Take aways
- Make use of RAII: no naked new!
- Move all cleanup to the destructor.
- Use only one resource per object (SRP).
- Use RAII classed provided by the STL, e.g. `std::vector`, `std::unique_ptr`,
`std::shared_ptr`,...
- `std::unique_ptr` > `std::shared_ptr` > raw pointer
- Raw pointers can still be used as long as they do not own the resource.
- Use `std::make_unique<T>` and `std::make_shared<T>`.
- Applying RAII makes application of the Rule of Zero more likely.

## Standard Template Library

### Overview
The Standard Template Library (STL) in C++ provides a set of tools available in C++ headers. The content includes containers, iterators, and algorithms. They are implemented as type-generic (more details on templates will be covered later in the lecture).

### Iterators
Iterators are used to traverse a collection of elements in a container. While they might seem useless if a container provides random access, for all other containers, iterators are the only way to iterate over the container. The types of the iterator of `std::vector<T>` are as follows:

- `std::vector<T>::iterator`
- `std::vector<T>::reverse_iterator`
- `std::vector<T>::const_iterator`
- `std::vector<T>::const_reverse_iterator`

Free functions such as `begin` and `end` return an iterator to the first and last element of the container respectively. Other functions like `next`, `advance`, and `operator++` can move the iterator. The iterator needs to be dereferenced by `operator*` or `operator->` to access an element or its members.

```cpp
#include <iostream>
#include <vector>
void print(std::string const& str, std::vector<int>::reverse_iterator const& it) {
    std::cout << "*(" << str << ") = " << *it << std::endl;
}
int main() {
    std::vector<int> v = {1,2,3,4,5,6,7,8};
    print("rbegin", std::rbegin(v));
    print("rbegin+1", std::rbegin(v)+1);
    std::vector<int>::reverse_iterator it = std::rbegin(v);
    std::advance(it,4);
    print("it-2", std::prev(it,2));
}

// What is printed?
// *(rbegin) = 8
// *(rbegin+1) = 7
// *(it-2) = 6
```

### Containers Overview

- type-generic
- value semantics
- RAII (Resource Acquisition Is Initialization)
- common interface

Types of Containers

- Sequence
- Associative
- Ordered
- Unordered

### Containers - Common Interface

Construction and Destruction

- Default constructor: `std::vector<int> v;`
- Count (and homogeneous initialization): `std::vector<int> v(4, 0);`
- Range: `std::vector<int> v(v1.begin(), v1.end());`
- Copy: `std::vector<int> v(v1);`
- Move: `std::vector<int> v(std::move(v1));`
- Sequence: `std::initializer_list<T>{} std::vector<int> v = {1,2,3,4};`
- Destructor: `delete v;`

Assignment and Swap

- Copy assign: `v = v1;`
- Move assign: `v = std::move(v1);`
- `std::initializer_list<T>` assign: `v = {1,2,3,4};`

Information

- Returns whether the container is empty: `v.empty();`
- Returns the current number of elements in the container: `v.size();`
- Returns the maximum number of elements the container is able to hold: `v.max_size();`

Insertion and Deletion of Elements

(Except for `std::array`)

- Insert an element after the specified location in the container: `v.insert(pos, 4);`
- Construct an element after the specified location in the container: `v.emplace(pos, 2);`
- Erase all elements from the container: `v.clear();`
- Erase an element at a specified position: `v.erase(pos);`

Comparison of Containers

(For containers of the same type)

- Equality (`operator==`): Same elements in the same sequence
- Inequality (`operator!=`)
- Ordering (`operator<`, `operator<=`, `operator>`, `operator>=`): Lexicographically

Iterators to Special Elements

- Returns an iterator to the beginning: `v.begin(); v.cbegin();`
- Returns an iterator to the end: `v.end(); v.cend();`
- Returns a reverse iterator to the beginning: `v.rbegin(); v.crbegin();`
- Returns a reverse iterator to the end: `v.rend(); v.crend();`

Others

- Swapping two containers (of the same type): `std::swap(v,v1);`
- Iterator-based loop: `for (std::vector<int>::iterator it=v.begin; it!=v.end(); it++)`
- Range-based loop: `for (int vi: v)`

### Sequence Container â€“ Vector

- Dynamic array
- Defined in header `<vector>`
- Variable length: Can grow during runtime
- Continuous storage (ideal memory layout)
- Over-allocation to avoid allocation for each insertion (`size() â‰¤ capacity()`)
- `std::string` can be considered as `std::vector<char>`

Element Access

- First element: `v.front()`
- Last element: `v.back()`
- Index access: `v[i]`
- Index access with boundary check (throws `std::out_of_range` exception for failure): `v.at(i)`
- Pointer arithmetic (due to contiguous storage): `*(&v[0]+i)`

Insertion and Deletion of Elements

- Append element to the end and allocate memory if capacity is exhausted: `v.push_back(22)`
- With in-place construction: `v.emplace_back(2.2)`
- Remove last element: `v.pop_back()`

Iterator

- (const) Iterator to the beginning
- (const) Iterator to the end
- (const) Reverse iterator to the beginning
- (const) Reverse iterator to the end

Refer to `vector.cpp` file for implementation

Pros and Cons
- Pros:
  - Dynamic array
  - Contiguous memory
  - No additional memory for pointer to next element
  - Random access: direct access to all elements
  - Cache efficient
- Cons:
  - Adding and removing elements (not at the end) will cause a shift
  - Reallocation requires transfer of the data to the new memory location

### Sequence Container â€“ Array
- Static array
- Defined in header `<array>`
- Static size/fixed length: cannot be changed during runtime
- Contiguous storage (ideal memory layout)
- Explicit default initialization is required: `std::array<int,5> a{}`
- Remaining elements are default initialized: `std::array<int,5> a{1,2,3}`

```cpp
# include <iostream>
# include <array>

template <typename T>
void print (T const& v) {
  std::cout << "v = { ";
  for (int i : v) std::cout << i << ", ";
  std::cout << "};\n";
}

int main() {
  std::array<int,10> v = {1,2,3,4,5,6};
  std::cout << "v: size: " << v.size() << ", &v[0]: " << &v[0] << std::endl;
  print(v);
  for (std::array<int,10>::iterator it=v.begin(); it!=v.end(); ++it)
    *it *= 2;
  print(v);
}
```

## Sequence Container

### Array
Arrays are a type of sequence container that use contiguous memory. They do not require allocation and do not use additional memory for pointers to the next element. They allow random access, which provides direct access to all elements, and are cache efficient. However, arrays are static and cannot be resized.

### Pros
- Contiguous memory
- No allocation required
- No additional memory for pointer to next element
- Random access: direct access to all elements
- Cache efficient

### Cons
- Static array

### List
Lists are sequence containers that represent doubly linked lists. They do not provide index access, but allow fast access to both the beginning and end of the list. Lists can grow in two directions.

```cpp
#include <iostream>
#include <list>
template <typename T> 
void print (T const& v) {
    std::cout << "v: size: " << v.size() << ", v = { ";
    for (int i : v) std::cout << i << ", ";
    std::cout << "}, addr 1st elem: " << &(*v.begin())
    << " , addr 2nd elem: " << &(*std::next(v.begin())) << "\n";
}
int main() {
    std::list<int> v = {1,2,3,4,5,6};
    print(v);
    for (std::list<int>::iterator it=v.begin(); it!=v.end(); ++it)
    *it *= 2;
    v.push_front(-1);
    v.emplace_back(42);
    print(v);
}
```

### Sequence Containers

### List

**Pros**
- Elements are allocated independently
- Efficient insertion and deletion of elements

**Cons**
- Each insertion causes an allocation
- No random access

### Forward List

A forward list is a singly linked list. It is defined in the header `<forward_list>`. Unlike other sequence containers, it does not provide index access. It allows fast access to the front (and end), can grow in one direction, but does not know its size. 

1 â†’ 2 â†’ 3 â†’ 4 â†’ 5 â†’ 6 â†’ 7 â†’ 8
size()
std::forward_list<int> container{1,2,3,4,5,6,7,8};

Sequence Container â€“ Forward List

```cpp
# include <iostream>
# include <forward_list>
template <typename T> void print (T const& v) {
std::cout << "v = { ";
for (int i : v) std::cout << i << ", ";
std::cout << "}, addr 1st elem: " << &(*v.begin())
<< " , addr 2nd elem: " << &(*std::next(v.begin())) << "\n";
}
int main() {
std::forward_list<int> v = {1,2,3,4,5,6};
print(v);
for (std::forward_list<int>::iterator it=v.begin(); it!=v.end(); ++it)
*it *= 2;
v.emplace_front(-1);
print(v);
}
```


### Sequence Container â€“ Forward List

**Pros**
- Elements are allocated independently
- Efficient insertion and deletion of elements
- Less memory overhead compared to list

**Cons**
- Each insertion causes an allocation
- No random access
- Only forward iterable

## Sequence Container â€“ Deque

Deque is a double-ended queue that is defined in the header `<deque>`. It's a sequence of arrays and provides functions at the front like `push_front`, `emplace_front`, and `pop_front`. Container adapters stack and queue are based on deque.

```c++
#include <iostream>
#include <deque>

template <typename T>
void print(T const& v) {
    std::cout << "v: size: " << v.size() << ", v = { ";
    for (int i : v) std::cout << i << ", ";
    std::cout << "}, addr 1st elem: " << &(*v.begin())
    << " , addr 2nd elem: " << &(*std::next(v.begin())) << "\n";
}

int main() {
    std::deque<int> v = {1,2,3,4,5,6};
    print(v);
    v[1] = 11;
    for (std::deque<int>::iterator it=v.begin(); it!=v.end(); ++it)
    *it *= 2;
    v.pop_front();
    v.emplace_back(42);
    print(v);
}
```

### Sequence Container â€“ Deque

### Pros
- Most of the elements are contiguous.
- Random access.
- Efficient insertion and deletion of elements at the front and back.
- Cache efficient.
- Less memory overhead compared to list.

### Cons
- Insertion in the middle causes a shift.

## Sequence Container â€“ Comparison

| Container | Dynamic Size | Random Access | Memory Reservation | Memory Release | Pros and Cons |
| --- | --- | --- | --- | --- | --- |
| Array | âœ— | âœ“ | Explicit | Explicit | + No allocation, + Memory req., - Static |
| Vector | âœ“ | âœ“ |  |  | + Performance, - Add/Remove (not at back) |
| Deque | âœ“ | âœ“ |  | âœ“ | + Add/Remove (front/back), - Add/Remove (others) |
| List | âœ“ | âœ— |  | âœ“ | + Add/Remove, - No random access |
| Forward List | âœ“ | âœ— |  | âœ“ | + Memory req., - No random access |

The table above provides a comparison between different types of sequence containers in terms of their dynamic size capability, ability to access randomly, memory reservation and release specifications, and their pros and cons.


### Associative Containers in C++

### Set
- Defined in header `<set>`
- Only stores keys
- Equivalent keys are not allowed
- Stored as a binary tree with logarithmic complexity for accessing, search, removal, and insertion

```cpp
#include <iostream>
#include <set>

template <typename T> 
void print (T const& s) {
    std::cout << "s: size: " << s.size();
    std::cout << ", s = { ";
    for (int i : s)
        std::cout << i << ", ";
    std::cout << "};\n";
}

int main() {
    std::set<int> s = {1,3,1}; 
    print(s);
    s.insert(2); 
    print(s);
    s.emplace(3); 
    print(s);
    std::cout << s.count(3) << std::endl;
    std::set<int> s2 = {3,5,6}; 
    print(s2);
    s.merge(s2); 
    print(s);
    print(s2);
}
```

## Associative Container â€“ Multiset

- Defined in header `<set>`
- Stores keys only
- Equivalent keys are allowed
- Storage as a binary tree
  
```cpp
std::multiset<int> container{1,2,2,4,5,7,7,8};
```

```cpp
# include <iostream>
# include <set>

template <typename T> void print (T const& s) {
std::cout << "ms: size: " << s.size();
std::cout << ", ms = { ";
for (int i : s)
std::cout << i << ", ";
std::cout << "};\n";
}

int main() {
std::multiset<int> s = {1,3,1}; print(s);
s.insert(2); print(s);
s.emplace(3); print(s);
std::cout << s.count(3) << std::endl;
std::multiset<int> s2 = {3,5,6}; print(s2);
s.merge(s2); print(s);
print(s2);
}
```

### Associative Container â€“ Map
The Map associative container is defined in the `<map>` header. It can be used to implement a dictionary and stores key-value pairs. It does not allow equivalent keys and stores the key-value pairs as a binary tree. The Map container provides an index access operator; if a key is not present, it will be inserted with a default value. 

{% raw %}
```cpp
std::map<int,char> container{{1,'t'},{2,'o'},{3,'m'},{4,'a'},{5,'t'},{7,'o'}};
```
{% endraw %}

```cpp
# include <iostream>
# include <map>
template <typename T> void print (T const& m) {
std::cout << "m: size: " << m.size();
std::cout << ", m = { ";
for (auto i : m)
std::cout << "[" << i.first << ", " << i.second << "], ";
std::cout << "};\n";
}
int main() {
std::map<std::string, int> m = {{"John", 2412},{"David", 123},{"Tom", 9}}; print(m);
m.insert({"Jude", 42}); print(m);
m["Albert"] = 66; print(m);
std::cout << m["david"] << std::endl; print(m);
std::map<std::string, int> m2 = {{"John", -1},{"Berta", -5},{"Tim", 1}} ; print(m2);
m.merge(m2); print(m);
print(m2);
}
```

### Associative Container â€“ Multimap

The Multimap associative container is also defined in the <map> header. It stores key-value pairs, and contrary to Map, it allows equivalent keys. The storage is also as a binary tree.


```cpp
std::multimap<int,char> container{{1,'t'},{2,'o'},{2,'m'},{4,'a'},{7,'t'},{7,'o'}};
```

```cpp
# include <iostream>
# include <map>
template <typename T> void print (T const& m) {
std::cout << "m: size: " << m.size();
std::cout << ", m = { ";
for (auto i : m)
std::cout << "[" << i.first << ", " << i.second << "], ";
std::cout << "};\n";
}
int main() {
std::multimap<std::string, int> m = {{"John", 2412},{"David", 123}}; print(m);
m.insert({"Jude", 42}); print(m);
std::multimap<std::string, int> m2 = {{"John", -1},{"Berta", -5}}; print(m2);
m.merge(m2); print(m);
print(m2);
std::cout << "Count 'John': " << m.count("John") << std::endl;
}
```

### Associative Container â€“ Unordered

Unordered set/multiset/map/multimap are defined in headers <unordered_set> and <unordered_map>. A hash function is applied to the key, and they have average constant complexity for accessing, search, removal, and insertion. The elements may not be modified (even by non-const iterators) since modification could change an elementâ€™s hash and corrupt the container.

Unordered set:
```cpp
# include <iostream>
# include <unordered_set>
template <typename T> void print (T const& s) {
std::cout << "s: size: " << s.size();
std::cout << ", s = { ";
for (int i : s)
std::cout << i << ", ";
std::cout << "};\n";
}
int main() {
std::unordered_set<int> s = {1,3,1}; print(s);
s.insert(2); print(s);
s.emplace(3); print(s);
std::cout << s.count(3) << std::endl;
std::unordered_set<int> s2 = {3,5,6}; print(s2);
s.merge(s2); print(s);
print(s2);
}
```

Unordered map:
```cpp
# include <unordered_map>
template <typename T> void print (T const& m) {
std::cout << "m: size: " << m.size();
std::cout << ", m = { ";
for (auto i : m) std::cout << "[" << i.first << ", " << i.second << "], ";
std::cout << "};\n";
}
int main() {
std::unordered_map<std::string, int> m
= {{"John", 2412},{"David", 123},{"Tom", 9}}; print(m);
m.insert({"Jude", 42}); print(m);
m["Albert"] = 66; print(m);
std::cout << m["david"] << std::endl; print(m);
std::unordered_map<std::string, int> m2
= {{"John", -1},{"Berta", -5},{"Tim", 1}} ; print(m2);
m.merge(m2); print(m);
print(m2);
}
```

## Algorithms Overview
- The C++ standard library provides a library of free functions for various purposes.
- These algorithms can be used to:
  - Search
  - Sort
  - Manipulate data
  - Gather other information such as count, minimum, maximum, etc.
- They are defined in the header `<algorithm>`, but can also be found in `<numeric>` and `<memory>`.
- There are over 100 algorithms provided.
- They operate on ranges denoted as [first, last).
- They can be customized with function objects (e.g., lambda-functions).
- [Here](https://www.fluentcpp.com/getthemap/) is a map of all the STL algorithms.

```c++
template <typename T> 
void print (T const& v) {
    std::cout << "v = { ";
    for (int i : v)
        std::cout << i << ", ";
    std::cout << "};\n";
}

int main() {
    int v[8];
    std::iota(std::begin(v), std::end(v), 2); print(v);
    std::random_shuffle(std::begin(v), std::end(v)); print(v);
    std::sort(std::begin(v),std::begin(v)+4); print(v);
    auto it = std::find(std::begin(v),std::end(v),7);
    if (it != std::end(v)) *it = -7; print(v);
    it = std::max_element(std::begin(v), std::end(v));
    *it = -1; print(v);
    std::cout << std::accumulate(std::cbegin(v), std::cend(v), 0) << "\n";
}
```

### Algorithms â€“ Example
- **Replace**
- **Adjacent difference**
- **Inner product**
- **Comparison of elements in two different containers**
- **Live:** [live algorithm.cpp](#)

### Container Benchmarking
Key factors to consider while benchmarking a container:
- **Traversal**
- **Finding a non-contained element**
- **Sorting**
- **Removing the first element**

Traversal
- **Live:** [traversal.cpp](#)
- **Expected ranking:**
    1. std::vector
    2. std::deque
    3. std::unordered_set
    4. std::list
    5. std::set

Find
- **Live:** [find.cpp](#)
- **Expected ranking:**
    1. std::unordered_set
    2. std::vector (sorted)
    3. std::set
    4. std::deque (sorted)
    5. std::vector
    6. std::deque
    7. std::list

Sort
- **Live:** [sort.cpp](#)
- **Expected ranking:**
    1. std::vector
    2. std::deque
    3. std::list

Remove
- **Live:** [remove.cpp](#)
- **Expected ranking:**
    1. std::vector
    2. std::deque
    3. std::list
    4. std::unordered_set
    5. std::set

### Take aways
- Before implementing your own container, think about adopting one from the Standard Template Library (STL).
- If in doubt, use `std::vector`.
- For a container of constant size, known at compile time, prefer `std::array` over `std::vector`.
- For unordered data, prefer `std::unordered_set` or `std::unordered_map` over `std::set` or `std::map` respectively.

## Templates

### Motivation (Container)

Inefficient code duplication for various data types. E.g., creating multiple pairs for different data types:

```cpp
struct pair_int_int {
    int first{};
    int second{};
    pair_int_int(int f, int s) : first{f}, second{s} {}
    // ... [other functions]
    int& get_first() { return first; }
    int& get_second() { return second; }
};

struct pair_double_int {
    double first{};
    int second{};
    pair_double_int(double f, int s) : first{f}, second{s} {}
    // ... [other functions]
    double& get_first() { return first; }
    int& get_second() { return second; }
};

// ... [other combinations of pair]
```

### Motivation (Function)

Multiple overloads for a simple `min` function for different data types:

```cpp
int min(int x1, int x2) {
    return (x1 < x2 ? x1 : x2);
}

double min (double x1, double x2) {
    return (x1 < x2 ? x1 : x2);
}

double min (int x1, double x2) {
    return (x1 < x2 ? x1 : x2);
}

double min (double x1, int x2) {
    return (x1 < x2 ? x1 : x2);
}
```

### Motivation (Macro)

Using macros to define generic structures, which can lead to hard-to-diagnose errors and code obfuscation:

```cpp
## define DEFINE_PAIR(TYPE) \
struct pair_##TYPE { \
    TYPE _first; \
    TYPE _second; \
}

DEFINE_PAIR(int);
DEFINE_PAIR(double);

pair_int p;
```

### Template Fundamentals

C++ templates establish a blueprint for creating classes, functions, variables, or type aliases. Key characteristics include:

- Acting as recipes for elements like classes or functions, with specific details provided later.
- Offering a parameterized framework for generic programming.
- Avoiding less robust solutions like type erasure or macros.
- Preventing code duplication and enhancing reusability.
- Being heavily utilized in the Standard Template Library (STL) for diverse functionalities.
- Typically defined in header files as their definitions are needed at compile-time.


Template Categories:
- Function templates (= recipe for functions with generic type)
    ```cpp
    template <typename T>
    T min(T x1, T x2) {
        return x1 < x2 ? x1 : x2;
    }
    ```
- Class templates (= recipe for classes with generic type)
    ```cpp
    template <typename T1, typename T2>
    struct pair {
        T1 first{};
        T2 second{};
    };
    ```

- Alias templates (= recipe for alias with generic type)
    ```cpp
    template <typename T>
    using interval_t = boost::numeric::interval<
        T,
        boost::numeric::interval_lib::policies<
            boost::numeric::interval_lib::save_state<
                boost::numeric::interval_lib::rounded_transc_std<T>
            >,
            boost::numeric::interval_lib::checking_base<T>
        >
    >;
    ```
- Variable templates (= recipe for compile time constants)
    ```cpp
    template <typename T>
    constexpr T pi = T(3.1415926535897932385L);
    ```

### Template Declaration and Definition

- **Template Declaration:** Similar to functions or classes, templates also have declarations that define their interfaces without specifying the actual implementation.
- **Template Definition:** This is the blueprint for generating code based on a corresponding template declaration. Unlike functions or classes, templates cannot have multiple identical definitions.
- **Template Parameters:** These are placeholders defined in the template declaration within angle brackets after the `template` keyword. They represent types or values that will be replaced by actual arguments in the template instantiation.
- **Template Arguments:** The specific types or values used to substitute the template parameters during the instantiation of a template are called template arguments.
- **Template Specialization:** The process by which a template is instantiated with specific template arguments replacing the corresponding template parameters is known as template specialization. This creates a unique version of the template for the given set of arguments.


Class Template:
```cpp
template <typename T1, typename T2> // T1 and T2 are template parameters
struct pair; // Template Declaration

template <typename T1, typename T2> // T1 and T2 are template parameters
struct pair { // Template Definition
    T1 first;
    T2 second;
};

pair<int,double> p; // specialization with int and double as template arguments
```

Function Template:
```cpp
template <typename T> // T is a template parameter
T min(T const&, T const&); // Function template declaration

template <typename T> // T is a template parameter
T min(T const& x1, T const& x2) { // Function template definition
    return x1 < x2 ? x1 : x2;
}

int main() {
    int i = min<int>(1,2); // specialization with int as template arguments
}
```

### Template Parameter Types

**Type parameters:** Declared by keywords class or typename.

```cpp
template <typename T> T min(T const& x1, T const& x2);
// template <class T> T min(T const& x1, T const& x2); // same as above
```

**Non-type template parameters:** Most common: integer (compile time constants) and enumeration types.

```cpp
template <typename T, size_t N>
class array {
    T data[N];
};
array<int, 8> v;
```

**Template-template parameters**

```cpp
template <typename T, template <typename S, std::size_t N> typename C>
using cont8_t = C<T,8>;
cont8_t<int, array> v2;
```

### class vs. typename

In the context of template parameters, the keywords class and typename are interchangeable.

```cpp
template <class T> class pair;
template <class T> T min(T const&, T const&);
```

This means exactly the same as:

```cpp
template <typename T> class pair;
template <typename T> T min(T const&, T const&);
```

But elsewhere in C++, it is not interchangeable!

```cpp
template <typename T> typename pair; // error
```

### Default Template Arguments

Template parameters can have default template arguments.

```cpp
template <typename T, size_t N=8>
struct array {
    T data[N];
};
```

Similar to function parameters with default arguments, default template arguments must occur at the end of the list (except for function templates). For function templates, the default value can be anywhere, when the rest of the template parameters can be deduced.

```cpp
template <std::size_t N=1, typename T>
void increment(T& x) {
    x += N;
}
```

### Two-Phase Translation

The process of translating templates divided into two phases:

- **Phase 1: Parsing**
  - In this phase, the compiler parses the template declaration and definition.
  - It checks for errors that can be detected independently of the template arguments, such as syntax errors or references to undefined expressions.
  - This phase is performed only once per template.

- **Phase 2: Instantiation**
  - The compiler performs full compilation for each instantiation of the template, i.e., for each unique set of template arguments.
  - This involves substituting the template arguments into the template and then compiling the resulting code.

### Keyword `typename`
- inside templates: keyword `typename`` indicates that a template argument dependent name is a type
- is required for phase 1 of translation

```cpp
template <typename T>
struct typewrapper {
    using TYPE = T;
};

template <typename T>
typename T::TYPE do_something() {
    return static_cast<typename T::TYPE>(1.0);
}

int main() {
    double d = do_something<typewrapper<double>>();
}
```

```cpp
template <typename T>
void do_something() {
    typename T::X* (*f)(typename T::Y);
}
// What is implemented in the function? function pointer declaration
```

```cpp
template <typename T>
void do_something() {
    typename T::X *f(T::Y);
}
// What is implemented in the function? object definition
```

```cpp
template <typename T>
void do_something() {
    T::X *f(T::Y);
}
// What is implemented in the function? multiplication
```

### Template Specialization

Template specialization is a feature that allows the customization of template functions or classes for specific types or values. This occurs when template parameters are replaced with template arguments, resulting in a specialized version of the function or class. These specialized versions are identified by a template ID, such as `array<int,8>` or `min<float>`. The specialization process occurs at compile time.

There are various methods to generate specializations:

- **Instantiation (also known as Implicit Specialization):** This occurs when the compiler automatically creates a specialization when it encounters a specific template's usage in the code. This process involves replacing template parameters with concrete types or values.
  - If no explicit specialization is provided by the user, the compiler generates entities from the template.
  - No instantiation of duplicate function definitions occurs.
  - Template parameters are substituted by template arguments.
  - This process requires the template's definition and declaration.
  
- **Implicit Instantiation:** This is similar to the above process. The compiler automatically generates a specialization when a template is used with a specific type or value that has not been explicitly specialized or instantiated.
    - This is also known as automatic or on-demand instantiation.
    - In class templates, only the used member functions are instantiated.

- **Explicit Instantiation:** This occurs when the programmer explicitly instructs the compiler to generate a specialization of a template for certain types or values.
    - Explicit instantiation occurs when the user instructs the compiler to generate a specialization.
    - The syntax is similar to a declaration, but the angle brackets are moved behind the class or function name and contain template arguments instead of template parameters.
    - For class templates, all member functions are instantiated.

- **Explicit Specialization:** This is a unique version of a template provided by the programmer for specific types or values. It allows for custom behavior for those particular types or values.
    - The implementation is provided by the user with all template parameters substituted by template arguments (full specialization).
    - This will be prioritized over instantiation and the primary template.
    - Requires primary template declaration.
    - The syntax is similar to explicit instantiation, but with empty angle brackets behind the template keyword and with definition.
    - Prefer function overload over explicit specialization of function template.

- **Partial Specialization:** Available for class templates but results in a template again.
    - Requires primary template declaration.

```cpp
// primary template
template <class T>
void foo(T t) {
    std::cout << "Primary template: " << t << "\n";
}

// specialized template for int
template <>
void foo<int>(int t) {
    std::cout << "Specialized template for int: " << t << "\n";
}

int main() {
    foo(42);  // Implicit specialization, calls the specialized template for int
    foo(3.14);  // Implicit instantiation, calls the primary template
}
```

```cpp
pair<double,std::string> p; // implicit instantiation
min(1,2); // implicit instantiation
```

```cpp
template class pair<int,double>; // explicit instantiation
template double min<double>(double x1, double x2); // explicit instantiation
```

```cpp
template <typename T1, typename T2> struct pair;

template <> 
struct pair<double, std::string> {
    void print() { std::cout << "This is a non-sense explicit specialization\n"; }
}; // explicit specialization
```

```cpp
template <typename T> T min(T x1, T x2);

template <>
int min<int>(int x1, int x2) {
    return -1;
} // explicit specialization
```





```cpp
template <typename T1, typename T2> struct pair;

template <typename T>
struct pair<int, T> {
    T data{};
    void print() { 
        std::cout << "This is a non-sense partial specialization\n"; 
    }
    void not_called() { 
        std::cout << "This is never called\n"; 
    }
};

int main() {
    pair<int, bool> p; // implicit instantiation
    p.print();
}
```

When it comes to function templates, there are two main stages in the process:

1. **Template argument deduction:** This is where the compiler tries to figure out what the template arguments are based on the function arguments. The compiler generates a list of candidate function templates where the function arguments can be successfully matched to the function parameters.

2. **Overload resolution:** Once the compiler has a list of candidates, it needs to decide which one is the best match. It does this by comparing the candidates based on several criteria.


```cpp
#include<iostream>

template <typename T>
void print(T val) { std::cout << "General" << std::endl; }
template <>
void print(double* val) { std::cout << "Specialization" << std::endl; }
template <typename T>
void print(T* val) { std::cout << "Overload" << std::endl; }

// print(T val) --overload--> print(T* val)
//    |
// specialization
//    |
//    V  
// print(double* val)

int main() {
    double d=1.5;
    print(&d);
}
```


```cpp
#include<iostream>

template <typename T>
void print(T val) { std::cout << "General" << std::endl; }
template <typename T>
void print(T* val) { std::cout << "Overload" << std::endl; }
template <>
void print(double* val) { std::cout << "Specialization" << std::endl; }

// print(T val) --overload--> print(T* val)
//                                  |
//                              specialization
//                                  |
//                                  V  
//                          print(double* val)

int main() {
    double d=1.5;
    print(&d);
}
```


### Function Templates

- Function template declaration:
    ```cpp
    template <typename T> // T is a template parameter
    T min(T const&, T const&); // Function template declaration
    ```
- Function template definition:
    ```cpp
    template <typename T> // T is a template parameter
    T min(T const& x1, T const& x2) { // Function template definition
        return x1 < x2 ? x1 : x2;
    }
    ```
- Definitions are required for instantiation (explicit declaration is not necessarily required)
- Begin of scope of `T` is just after `template <typename T>`
- End of scope of `T` is at the end of the function definition after the closing curly bracket

### Template Argument Deduction

- Every template argument must be known at compile time for instantiation
- Template arguments inside the angle brackets <> can often be omitted for function templates
- Instead the compiler will try to deduce the non specified template arguments
- Enables operators with template parameter without calling them as functions

```cpp
template <typename T> // T is a template parameter
T min(T const& x1, T const& x2) { // Function template definition
    return x1 < x2 ? x1 : x2;
}

int main() {
    min(1,2); // The compiler deduces T as 'int'
    min(1.0,2.0); // The compiler deduces T as 'double'
    min<double>(1,1.0); // Explicit specification of T as 'double'
}
```

- Explicit specified template arguments via partial instantiation are deduced trivially
- Each non-specified template argument is deduced separately by checking its usage in the function parameter
- Default argument (of present) is used if template argument cannot be deduced
- Compilation fails if deduction is ambiguous or any template argument is unspecified and cannot be deduced

```cpp
template <typename T> // T is a template parameter
T min(T const& x1, T const& x2) { // Function template definition
    return x1 < x2 ? x1 : x2;
}

int main() {
    min(1.0,2); // Error: deduction of template argument fails due to ambiguity.
    // The compiler cannot deduce T as 'int' or 'double'
}
```

- Type deduction of template arguments only works on function parameters not on return types

```cpp
template <typename T>
T f();

int main() {
    int i = f(); // Error: Deduction fails, it only works on parameters
    int j = f<int>(); // Explicit specification of T as 'int'
}
```

### Template Argument Deduction and References

When a template parameter is a reference or pointer, the compiler uses a different set of rules to deduce its type. If the function argument is a reference, it is treated as the referred type during deduction. After the deduction, the reference part is added back to the deduced type.

```cpp
template<typename T>
void f(T& param);
f(expr);
```

- Deduced type: T
- Type of param: ParamT, e.g. T&
- T and param are deduced by using expr

Rules: Value Parameters:

- If type of expr is a reference, ignore reference
- If type of expr is top-level const or volatile, ignore const or volatile
    ```cpp
    template <typename T>
    void f(T param) {}
    int main() {
    int i = 22; int const ic = 42; int const& icr = i;
    f(i); // type of param = int, T = int
    f(ic); // type of param = int, T = int
    f(icr); // type of param = int, T = int
    f(22); // type of param = int, T = int
    int const* icp; int const* const icpc = &ic; int * const ipc = &i;
    f(icp); // type of param = int const*, T = int const*
    f(icpc); // type of param = int const*, T = int const*
    f(ipc); // type of param = int *, T = int *
    }
    ```

Rules: Reference and Pointer Parameters:
- If type of expr is a reference, ignore reference
- Pattern matching of expr against param to determine `T`

```cpp
template <typename T>
void f(T& param) {}

int main() {
    int i = 22; int const ic = 42; int const& icr = i;
    f(i); // type of param = int, T = int
    f(ic); // type of param = int const&, T = int const
    f(icr); // type of param = int const&, T = int const
    int * ip; int const* icp; int const* const icpc = &ic; int * const ipc = &i;
    f(ip); // type of param = int *&, T = int *
    f(icp); // type of param = int const*&, T = int const*
    f(icpc); // type of param = int const*const&, T = int const*const
    f(ipc); // type of param = int *const&, T = int *const
}
```

Reference Collapsing:
- Compiler substitutes the type of Expr for T into ParamT
- Drop of one const qualifier if there are two const qualifiers in a row
- Drop of const qualifier of outer reference
- Application of reference collapsing
- Reference collapsing rules:
    - & + & â†’ &
    - & + && â†’ &
    - && + & â†’ &
    - && + && â†’ &&

### Forwarding References and Perfect Forwarding

A forwarding reference is a special kind of reference that preserves the value category (lvalue or rvalue) of a function argument. It is used in template functions where the template parameter type is `T&&`.

Perfect forwarding is a technique that allows a function template to pass its arguments through to another function, while preserving their value category.

Forwarding Reference:
- Forwarding reference or universal reference
- Looks like rvalue reference but must be involve type deduction, i.e. T&& or auto&&
- Represents lvalue reference if initialized with lvalue
- Represents rvalue reference if initialized with rvalue
- Reminder: lvalue would not bind to an rvalue reference
- Applies reference collapsing rules in case of lvalue is passed

Rules: Forwarding: Reference Parameter
- if type of expr is lvalue or lvalue reference, T is lvalue reference of type of expr (reference
collapsing applied after pattern matching)
- if type of expr is rvalue, T is deduced by pattern matching

```cpp
template <typename T>
void f(T&& param) {}

int main() {
    int i = 22; int const ic = 42; int const& icr = i;
    f(i); // type of param = int&, T = int&
    f(ic); // type of param = int const&, T = int const&
    f(icr); // type of param = int const&, T = int const&
    f(22); // type of param = int &&, T = int
    int * ip = &i; int const* icp; int const* const icpc = &ic; int * const ipc = &i;
    f(icp); // type of param = int const*&, T = int const*&
    f(icpc); // type of param = int const*const&, T = int const*const&
    f(ipc); // type of param = int *const&, T = int *const&
    f(&i); // type of param = int *&&, T = int *
}
```

- if type of expr is lvalue or lvalue reference, T is lvalue reference of type of expr (reference collapsing applied after pattern matching)
- if type of expr is rvalue, T is deduced by pattern matching

```cpp
template <typename T>
void f(T&& param) {}

int main() {
    int i = 22; int const ic = 42; int const& icr = i;
    f(i); // type of param = int&, T = int&
    f(ic); // type of param = int const&, T = int const&
    f(icr); // type of param = int const&, T = int const&
    f(22); // type of param = int &&, T = int
    int * ip = &i; int const* icp; int const* const icpc = &ic; int * const ipc = &i;
    f(icp); // type of param = int const*&, T = int const*&
    f(icpc); // type of param = int const*const&, T = int const*const&
    f(ipc); // type of param = int *const&, T = int *const&
    f(&i); // type of param = int *&&, T = int *
}
```

**Perfect Forwarding:**
- `std::forward<T>` (defined in <utility>) for perfect forwarding
- `std::forward<T>` is a conditional cast (compare to `std::move`), it only casts to rvalue reference if T was already an rvalue
- preserves type of template argument
- calling `std::move` would result in wrong code if lvalue was passed

```cpp
# include <utility>

template <typename T> 
void g(T&& x) {}

template <typename T> 
void f(T&& x) { 
    g(std::forward<T>(x)); 
}

int main() {
    f(true);
    int a;
    f(a);
}
```

**`std::move` vs `std::forward`:**
While both `std::move` and `std::forward` can cast their arguments to rvalue references, there is a key difference between them. `std::move` unconditionally casts its argument to an rvalue reference, which enables move semantics. On the other hand, `std::forward` conditionally casts its argument to an rvalue reference only if the original argument was an rvalue, thereby preserving the original value category.


```cpp
#include <type_traits>

template <typename T>
std::remove_reference_t<T>&& move(T&& t) {
    return static_cast<std::remove_reference_t<T>&&>(t);
}

template <typename T>
T&& forward(std::remove_reference_t<T>& t) {
    return static_cast<T&&>(t);
}

int main() {
    move(4);
    int x;
    forward<int>(x);
}
```

### Class Templates

Class template declaration:

```cpp
template <typename T1, typename T2> // T1 and T2 are template parameters
struct pair; // Template Declaration
```

Class template definition:

```cpp
template <typename T1, typename T2> // T1 and T2 are template parameters
struct pair { // Template Definition
    T1 first;
    T2 second;
};
```

- definitions are required for instantiation (explicit declaration is not necessarily required)
- for specific cases Class Template Argument Deduction is available (but not recommended)
- Begin of scope of T is just after template `<typename T>`
- End of scope of T is at the end of the class definition (after the semicolon)
- Within the scope of a class template, the template arguments can be omitted. This is because the template arguments are already known within the class.

```cpp
template <typename T1, typename T2>
struct pair {
    T1 first;
    T2 second;

    // Here we omit the template arguments for pair as they are implicitly known
    pair& operator+=(const pair& other) {
        first += other.first;
        second += other.second;
        return *this;
    }
};

int main() {
    pair<int,double> p1, p2;
    p1 += p2;
}
```

Member functions of a class template can be defined outside the class scope. However, remember to include the template parameters in the function signature when doing so.

```cpp
template <typename T1, typename T2>
struct pair {
    T1 first;
    T2 second;
    // Declare the operator overloading function
    pair& operator+=(const pair&);
};

// Define the operator overloading function outside the class scope
template <typename T1, typename T2>
pair<T1,T2>& pair<T1,T2>::operator+=(const pair& other) {
    first += other.first;
    second += other.second;
    return *this;
}
```

The scope of a class template begins after the `::` of a member function definition and extends until the end of the definition. This scope includes the function body and any exception specifications, but does not include the function's trailing return type, if any.

### The `auto` Type Specifier

- The auto keyword is used in C++ to deduce the type of an expression automatically, enabling you to declare variables without explicitly specifying their types.
    - ```cpp
        std::vector<std::vector<double>> v; auto it = v.crbegin(); 
        // Type of 'it' is deduced as std::vector<std::vector<double>>::const_reverse_iterator
        ```
- When declaring multiple variables with auto, their deduced types must be identical
    - ```cpp
        auto i = 0, *pi = &i;
        // T = int, type of i = int, type of pi = int*
        ```
- The type deduction process for auto follows the same rules as template type deduction.
- The specific deduction rules depend on the usage syntax:
  - `auto& ri = i; // T = int, type of ri = int&`
  - `auto&& ri2 = i; // T = int&, type of ri2 = int&`
  - `auto&& rri = i++; // T = int, type of rri = int&&`

**`auto` Type Specifier â€“ as Parameter Type:**
- The `auto` keyword is allowed in function parameters.
- The type will be deduced based on the template argument deduction rules.
- The function is effectively a template.

```cpp
void print1(auto&& x) {
    std::cout << x << std::endl;
}
template <typename T>
void print2(T&& x) {
    std::cout << x << std::endl;
}
int main() {
    print1(42);
    print2(22);
}
```

**`auto` Type Specifier â€“ as Return Type:**
- auto can be used as a return type. 
- However, all return statements within the function must deduce to the same type.

```cpp
# include <iostream>

auto fac(int n) {
    return n==0 ? 1 : n * fac(n-1);
}

int main() {
    std::cout << fac(4) << std::endl;
}
```

When used in member function definitions, `auto` can help enhance readability:

```cpp
template <typename T1, typename T2>
struct pair {
    T1 first;
    T2 second;
    auto& operator+=(pair const&);
};

template <typename T1, typename T2>
auto& pair<T1,T2>::operator+=(pair const& other) {
    first += other.first;
    second += other.second;
    return *this;
}

int main() {
    pair<int,double> p1, p2;
    p1 += p2;
}
```

**`auto` Type Specifier â€“ Trailing Return:**

The return type of a function can be declared after its parameter list, with auto acting as a placeholder for the return type.

```cpp
template <typename T1, typename T2>
struct pair {
    T1 first;
    T2 second;
    auto operator+=(pair const&) -> pair&;
};

template <typename T1, typename T2>
auto pair<T1,T2>::operator+=(pair const& other) -> pair& {
    first += other.first;
    second += other.second;
    return *this;
}
```

### Variadic templates
- Template parameter packs for arbitrary number of template arguments: typename ... Ts
- Corresponding function argument parameter pack: Ts ... ts
- Number of arguments in a function argument parameter pack: sizeof...(ts)
- Expansion of the parameter pack: ts ...
- Can be used to inherit from multiple types
- If used in recursive call, an explicit specialization of the recursive termination is required

```cpp
#include <iostream>

template <typename T>
T min(T const& x) {
    return x;
}

template <typename T, typename ... Ts>
auto min(T const& x1, T const& x2, Ts const& ... ts) {
    T m = (x1 < x2) ? x1 : x2;
    return min(m, ts...);
}

int main() {
    std::cout << min(1, 2, 3, 4, 5, -2, 7, 8) << std::endl;
}
```

### Fold expressions

Fold expressions allow the application of binary operations to parameter packs.

```cpp
#include <iostream>
#include <vector>
#include <utility>

template<typename T>
struct vector_adaptor {
    std::vector<T> v;

    vector_adaptor() = default;

    template <typename ... Ts>
    void push_negative(Ts&& ... ts) {
        (v.push_back(-std::forward<Ts>(ts)), ...);
    }
};

int main() {
    vector_adaptor<int> v;
    v.push_negative(2, 4, 76);
    
    for (int i : v.v) {
        std::cout << i << std::endl;
    }
}
```

### Take aways
- Leverage generic programming, particularly template programming, to minimize code duplication.
- Place your template definitions in header files to simplify their use across different source files.
- Use implicit instantiation whenever possible to help compiler generate code.
- Favor function overloads over explicit specialization of function templates for clearer and safer code.
- Exploit templates for enhanced code maintainability.
- Exercise caution while using class template argument deduction due to its potential complexity.
- Familiarize yourself with the rules of template argument deduction.
- Understand that the auto type specifier uses the same deduction rules as template type deduction.

## Metaprogramming

### `constexpr` specifier

The `constexpr` keyword signals that a variable or function can be evaluated at compile time.

- **`constexpr` variables** must be initialized immediately. 
- **`constexpr` variables** can only depend on other constant expressions.
- It's a good practice to also declare your **`constexpr` variables** as static.

```cpp
#include <array>
int main() {
    constexpr int N = 5*4;
    std::array<int, N> arr;
}
```

Compilation fails in the following example, as the variable depends on a non-constant expression:

```cpp
#include <array>
int main(int argc, char*argv[]) {
    constexpr int N = 5*argc; // Not allowed
    std::array<int, N> arr;
}
```

- **`constexpr` functions** can only be evaluated at compile time if all their arguments are known at compile time. 
- Otherwise, **`constexpr` functions** are guaranteed to be evaluated at run time. 
- If the return value of a **`constexpr` function** is assigned to a **`constexpr` variable**, the function either gets evaluated at compile time or results in a compile error.

```cpp
constexpr int fac(int n) {
    return (n==1) ? 1 : n*fac(n-1);
}
int main(int argc, char *argv[]) {
    int m1 = fac(argc); // Guaranteed run time evaluation
    int m2 = fac(4); // Likely run time evaluation
    constexpr int m4 = fac(4); // Guaranteed compile time evaluation
    std::cout << m1 << " " << m2 << " " << m4 << std::endl;
}
```

```cpp
// Template function that calculates the factorial at compile time
template <int N>
constexpr int fac() {
    return (N==1) ? 1 : N*fac<N-1>();  // If N=1, return 1. Else, return N times factorial of N-1
}

int main() {
    constexpr int f4 = fac<4>();  // Compute factorial of 4 at compile time
    std::cout << f4 << std::endl;  // Output the result
}
```

Note that STL algorithms are implemented as `constexpr` functions.

`constexpr` variables and functions can be used as conditions in **`constexpr` `if` statements**.

### `consteval` specifier

- `consteval` functions, also known as **immediate functions**, are guaranteed to be evaluated at compile time.
- Arguments of an **immediate function** must be constant expressions, i.e., known at compile time.

```cpp
consteval int fac(int n) {
    return (n==1) ? 1 : n*fac(n-1);
}

int main(int argc, char *argv[]) {
    int m2 = fac(4); // Guaranteed compile time evaluation
    constexpr int m4 = fac(4); // Guaranteed compile time evaluation
    std::cout << m2 << " " << m4 << std::endl;
}
```

**consteval if statements** check whether the function is evaluated at compile time.

```cpp
// consteval function, it's guaranteed to execute at compile time
template <int N>
consteval int fac() {
    return (N==1) ? 1 : N*fac<N-1>();
}

int main() {
    constexpr int f4 = fac<4>();
    std::cout << f4 << std::endl;
}
```

```cpp
#include <iostream>

// consteval ensures that the functions are executed at compile time.

consteval int sqr(int n) {
    return n*n;
}

consteval int f(int n) {
    return sqr(n);
}

int main() {
    constexpr int n=3; // can be evaluated at compile time
    std::cout << f(n) << std::endl; // Prints: 9
}
```

```cpp
#include <iostream>

// constexpr does not guarantee compile-time evaluation but allows it

constexpr int sqr(int n) { 
    return n*n; 
}

constexpr int f(int n) {
    return sqr(n);
}

int main() {
    constexpr int n=f(3); // does not guarantee compile-time evaluation but allows it
    std::cout << n << std::endl; // Prints: 9
}
```

### static_assert
- `static_assert` checks whether a compile-time constant expression evaluates to true.
- It raises a compilation error if the expression evaluates to false.
- `static_assert` takes an optional error message as an argument.

```cpp
template <int N>
constexpr int fac() {
    return (N==1) ? 1 : N*fac<N-1>();
}
int main() {
    constexpr int f4 = fac<4>();
    static_assert(f4==24, "4! = 24");
}
```

### Metafunctions

- **Metafunction:** A metafunction is a class or struct that performs computation at compile time.
- **Return Value:** The "return value" of a metafunction isn't obtained through a typical function call, but by accessing specific member types or static member values. This is a convention in template metaprogramming.
- **Invocation:** A metafunction is "invoked" or "called" by accessing these member types or values.
- **Compile-time:** Metafunctions operate entirely at compile time, working on static information that is available before the program is run.


```cpp
template <auto X, auto Y>
struct Sum {
    static constexpr int value = X+Y;
};

int main() {
    static_assert(12 == Sum<14,-2>::value);
}
```

### Type Traits in Depth
**Type Traits** are parameterized classes or structs that carry metadata about a specific data type. These properties are resolved at compile time, providing static information about the type. They're typically implemented in the `<type_traits>` header and make use of explicit specialization. Here are the categories of **Type Traits**:
- Constants
- Relationships
- Primary and Composite Type Categories
- Type Properties
- Supported Operations
- Modifications
- Transformations
- Numeric Limits

Type Traits define helper structures for **constants**. Other traits often inherit from these basic structures. The information is usually stored in a member named value. For instance, `integral_constant` is a basic structure:

```cpp
template <typename T, T v>
struct integral_constant {
    static constexpr T value = v;
};

using true_type = integral_constant<bool, true>;
using false_type = integral_constant<bool, false>;

int main() {
    static_assert(integral_constant<int,2>::value == 2);
    static_assert(true_type::value == true);
    static_assert(false_type::value == false);
}
```

**Relationship** type traits provide information about the relationship between two data types. Some examples `include is_same<T,U>`, `is_base_of<T,U>`, and `is_convertible<T,U>`. An example implementation of `is_same`:

```cpp
template <typename T, typename U>
struct is_same : false_type {};

template <typename T>
struct is_same<T,T> : true_type {};

int main() {
    static_assert(is_same<int,int>::value == true);
    static_assert(is_same<int,bool>::value == false);
    static_assert(is_same<int,int&>::value == false);
}
```

**Primary type categories** provide information about a data type, stored as a boolean value in member value. Examples include `is_void<T>`, `is_floating_point<T>`, `is_array<T>`, `is_class<T>`, `is_function<T>`, `is_pointer<T>`, `is_lvalue_reference<T>`, and `is_rvalue_reference<T>`, among others.

An example implementation of `is_floating_point`:

```cpp
template <typename T> 
struct is_floating_point : false_type {};

template <> 
struct is_floating_point<float> : true_type {};

template <> 
struct is_floating_point<double> : true_type {};

template <> 
struct is_floating_point<long double> : true_type {};
```

Alternative implementation of `is_floating_point`:

```cpp
template <typename T>
struct is_floating_point : integral_constant<bool,
    is_same<T,float>::value ||
    is_same<T,double>::value ||
    is_same<T,long double>::value
> {};
```

**Composite type categories** combine information from primary type categories. Examples include `is_arithmetic<T>`, `is_fundamental<T>`, `is_compound<T>`, `is_scalar<T>`, and `is_reference<T>`.

An example implementation of `is_reference`:

```cpp
template <typename T> 
struct is_reference : false_type {};

template <typename T> 
struct is_reference<T&> : true_type {};

template <typename T> 
struct is_reference<T&&> : true_type {};
```

Alternative implementation of `is_reference`:

```cpp
template <typename T>
struct is_reference
: integral_constant<bool,
    is_lvalue_reference<T>::value ||
    is_rvalue_reference<T>::value
> {};
```

**Type properties** inform us about certain properties of a type. Examples include `is_const<T>`, `is_volatile<T>`, `is_signed<T>`, and `is_abstract<T>`.

**Supported operations** inform us if a type supports certain operations. Examples include `is_constructible<T,Args...>`, `is_assignable<T,U>`, and `is_nothrow_move_assignable<T>`.

**Type modification traits** are used to modify a type. The modified type is stored in a member called type. Examples include `remove_reference<T>`, `add_reference<T>`, `remove_pointer<T>`, `add_pointer<T>`, `remove_cv<T>`, `add_cv<T>`, and `make_unsigned<T>`.

Example implementation of `remove_reference`:

```cpp
template <typename T> struct remove_reference { using type = T; };
template <typename T> struct remove_reference<T&> { using type = T; };
template <typename T> struct remove_reference<T&&> { using type = T; };

template <typename T>
typename remove_reference<T>::type&& move(T&& t) {
    return static_cast<typename remove_reference<T>::type&&>(t);
}
```

**Type transformations** are useful, for instance, when restricting templates. Examples include `conditional<B,T,F>`, `enable_if<B,T>`, `type_identity<T>`, `common_type<T,U>`, and `void_t<T...>`.

Example usage of `enable_if`:

```cpp
template <typename T, typename U>
typename std::enable_if<
    std::is_arithmetic<T>::value && std::is_arithmetic<U>::value,
    typename std::common_type<T,U>::type
>::type
min(T x, U y) {
    return x<y ? x : y;
}
```

**Numeric limits** provide a way to query various properties of arithmetic types, and is defined in the `<limits>` header. Usage differs from other type traits. Examples include `has_infinity<T>`, `is_exact<T>`, and `std::numeric_limits<T>::min()`.

```cpp
#include <limits>
#include <iostream>

template <typename T>
void print_info() {
    std::cout << std::numeric_limits<T>::min() << " "
              << std::numeric_limits<T>::lowest() << " "
              << std::numeric_limits<T>::max() << " "
              << std::numeric_limits<T>::epsilon() << " "
              << std::endl;
}

int main() {
    print_info<int>();
    print_info<long long>();
    print_info<float>();
    print_info<double>();
}
```

Instead of writing ::value and ::type, you can use _v or `_

### Template Restrictions in C++
The `enable_if` type trait is used to selectively disable or enable template instantiations, based on a type property. 

This is done by manipulating the **SFINAE** (Substitution Failure Is Not An Error) mechanism in C++. When the substitution of template arguments results in an invalid code, the compiler disregards this template silently, and attempts to find another template match.

This template availability control extends further with the introduction of features such as the `if constexpr` (since C++17 standard) and concepts (since C++20 standard). They make the code cleaner and easier to read, by using type traits and compile-time checks respectively.

`enable_if` can be used in multiple ways:

As an additional function argument. However, this method can't be used for operators.
```cpp
template <typename T>
void print(T x, std::enable_if_t<std::is_integral_v<T>, void>* = 0) {
    std::cout << "integral" << std::endl;
}
```

As a return type. But, this isn't applicable for constructors.

```cpp
template <typename T>
std::enable_if_t<std::is_floating_point_v<T>, void> print(T x) {
    std::cout << "floating point" << std::endl;
}

As an additional template argument.

```cpp
template <typename T, std::enable_if_t<!std::is_arithmetic_v<T>, bool> = true>
void print(T x) {
    std::cout << "non arithmetic" << std::endl;
}
```

Make sure not to introduce ambiguities while using `enable_if`.

Using `if constexpr`, same functionality as `enable_if` but with a strict order of checking conditions.

```cpp
template <typename T>
void print(T x) {
    if constexpr (std::is_integral_v<T>) {
        std::cout << "integral" << std::endl;
    } else if constexpr (std::is_floating_point_v<T>) {
        std::cout << "floating point" << std::endl;
    } else if constexpr (!std::is_arithmetic_v<T>) {
        std::cout << "non arithmetic" << std::endl;
    }
}
```

**Concepts**, introduced in C++20, are named requirements that constrain template parameters. They provide compile-time information and produce more descriptive error messages.

You can use type traits to define requirements for concepts. Concepts can have multiple requirements.
Concepts can be used inside `if constexpr`, static_assert statements, and as a required clause before or after the function signature. They can also replace the typename in template type parameters or be used with auto type deduction.

```cpp
// Definition of a concept using type trait
template <typename T>
concept integral = std::is_integral_v<T>;

// Concepts can be logically combined
template<class T>
concept signed_integral = integral<T> && std::is_signed_v<T>;
```

```cpp
// Usage of a concept
template <std::floating_point T>
void foo(T const& d) {
    std::cout << "T is floating_point and has value " << d << std::endl;
}
```

### Take aways
- Use `if constexpr` for conditional statements based on compile-time information.
- Use `consteval` to force constant expressions to be computed at compile time.
- Restrict your function and class templates by type traits or concepts to avoid code duplication.
- Prefer **concepts** over **type traits** for better compilation errors and easier-to-read code.
- Keep the principle of SFINAE in mind when working with templates.



## Expression Templates

### Motivation

Expression templates are a powerful meta-programming technique in C++. Let's consider a scenario of adding two objects of type `std::vector` using the infix notation (i.e., `operator+`):

```cpp
std::vector<int> a = {1,2,3,4,5,6};
std::vector<int> b = {8,7,6,5,4,3};
auto z = a + b;
```

The `operator+` can be implemented as follows:

```cpp
template <typename T>
std::vector<T> operator+(std::vector<T> const& a, std::vector<T> const& b) {
    std::vector<T> res(a.size());
    for (std::size_t i=0; i<a.size(); ++i) {
        res[i] = a[i] + b[i];
    }
    return res;
}
```

However, if we want to add three objects of type `std::vector`, the infix notation still works, but it will require intermediate memory allocations and two iterations (one for each operation).

This problem can be mitigated by implementing a function that takes three vectors as arguments, thus avoiding extra memory allocations and needing only one loop:

```cpp
template <typename T>
std::vector<T> add(std::vector<T> const& a, std::vector<T> const& b, std::vector<T> const& c) {
    std::vector<T> res(a.size());
    for (std::size_t i=0; i<a.size(); ++i) {
        res[i] = a[i] + b[i] + c[i];
    }
    return res;
}
```

However, using such an implementation, the `operator+` notation is no longer available for three arguments.

**Expression templates** solve this problem by introducing types that encapsulate the information required for an expression. Here's an example for the addition of two vectors:

```cpp
template <typename T1, typename T2>
struct VecSum {
    T1 const& a;
    T2 const& b;
    VecSum(T1 const& a, T2 const& b) : a(a), b(b) {}
    auto operator[](int i) const { return a[i] + b[i]; }
    auto size() const { return a.size(); }
};

template <typename T1, typename T2>
auto operator+(T1 const& a, T2 const& b) {
    return VecSum<T1,T2>(a,b);
}
```

With the implementation above, the usage remains the same as before. The type of z would be `VecSum<VecSum<std::vector<int>, std::vector<int>>,std::vector<int>>`. Operator overloading builds up an expression tree, but no computations are performed until the elements of the result vector are accessed.

Expression templates provide several advantages:
- Avoid runtime losses associated with operator overloading.
- Enable lazy evaluation, which results in better memory access patterns.
- Prevent allocation of intermediate results.

### Implementation
Expression templates utilize an expression class and an expression leaf class, which are defined using variadic templates and std::tuple. The types of arguments could also be expressions.

```cpp
struct ExprBase {};

template <typename OP, typename ... ARGS>
struct Expression : ExprBase {
    using Op = OP;
    Expression(ARGS const& ... args) : args_(args...) { }
    decltype(auto) args() const { return args_; }
    const std::tuple<ARGS ...> args_;
};

struct ExprLeafBase {};

template<typename VALUE_T>
struct ExpressionLeaf : ExprLeafBase {
    using value_t = std::remove_cvref_t<VALUE_T>;
    value_t value_;
    // ...
};
```

### Further Concepts Implementation

These concepts check if a given template type T is an expression leaf or an expression.

```cpp
template <typename T>
concept any_leaf = std::is_base_of_v<ExprLeafBase, std::remove_reference_t<T>>;

template <typename T>
concept any_expr_or_leaf = any_expr<T> || any_leaf<T>;

template <typename T, typename S>
concept any_is_expr_or_leaf = any_expr_or_leaf<T> || any_expr_or_leaf<S>;
```

### Entry Points for Operations

The following methods serve as entry points for operations involving operands of any expression and expression leaf type:

```cpp
template <typename X_T, typename Y_T>
requires any_is_expr_or_leaf<X_T,Y_T>
auto operator+(X_T&& x, Y_T&& y) {
    return Expression<OpAdd, X_T, Y_T>(x, y);
}

template <any_expr_or_leaf X_T>
auto sin(X_T&& x) {
    return Expression<OpSin, X_T>(x);
}
```

Note that class template argument deduction is not available due to operation struct.

### Operation Struct Implementation with Lambda Functions

Lambda functions are used for implementing operations. Details will be provided in the next lecture:

```cpp
struct OpAdd {
    static constexpr auto eval=[](auto&& x, auto&& y){
        return value(x) + value(y);
    };
};

struct OpSin {
    static constexpr auto eval=[](auto&& x){
        using std::sin;
        return sin(value(x));
    };
};
```

### Free Function Value

The free function value is used to compute the value of an expression. It is called recursively on expressions:

```cpp
template <typename T>
decltype(auto) value(T const& x) {
    if constexpr (any_expr<T>)
        return std::apply(typename T::Op().eval, x.args());
    else if constexpr (any_leaf<T>)
        return x.value_;
    else
        return x;
}
```

### Evaluation Triggering

The evaluation is triggered in the copy constructor and the copy assignment operator of the expression leaf class:

```cpp
template<typename VALUE_T>
struct ExpressionLeaf : ExprLeafBase {
    using value_t = std::remove_cvref_t<VALUE_T>;
    value_t value_;

    ExpressionLeaf(EXPR const& expr) : value_(value(expr)) {}

    template<any_expr EXPR>
    ExpressionLeaf& operator=(EXPR const& expr) {
        value_ = value(expr);
        return *this;
    }
};

std::ostream& operator<<(std::ostream& ofs, any_expr auto&& x) {
    ofs << value(x);
    return ofs;
}
```

In the motivation, the trigger was at the `operator[]`.

### Use Cases
Expression templates are widely used in linear algebra libraries like Eigen. They allow for assignment-level preaccumulation (also known as statement level reverse) in the field of algorithmic differentiation.

These templates reduce the number of nodes in graph structures from elemental operations (unary and binary operators and intrinsic functions) to assignment level, reducing the total number of operations if the graph is evaluated multiple times in the forward or reverse mode of algorithmic differentiation. They multiply along paths and sum over parallel paths.

### Take aways
- Expression templates enable infix notation without runtime losses associated with operator overloading. They are not a performance optimization technique.
- You should know the basics of expression templates, including expression trees, operation structs, and entry point implementation.

## Callables

### Motivation

Consider a function that accepts another function as an argument (or as a return value). Such functions are termed higher-order functions. For example, we might want to filter a vector using a variable predicate. In this lecture, we'll explore how this can be achieved through various forms of 'callables' in C++, such as function pointers, `std::function`, functors, and lambdas.

### Function Pointers

**Function pointers** are declared with a return type, followed by an asterisk and the function name, encapsulated in parentheses, and followed by the function parameters in parentheses: `return_t (*func_ptr) (parameters_t)`. They are assigned using the function's name (`func_ptr = func_name`) and invoked by dereferencing the function pointer (`return_t x = *func_ptr;`).

```cpp
bool leq_five(int x) { return (x<=5); }
int main() {
    bool (*func)(int) = leq_five;
    bool leq_five_v = func(5);
    std::cout << leq_five_v << " " << func(6) << " " << (*func)(1) << std::endl;
}
```

### `std::function`

**`std::function`** is a polymorphic function wrapper that can be used to store callable objects. It is declared as `std::function<return_t(parameters_t)>` and can be called just like a function.

```cpp
#include <functional>

bool leq_five(int x) { return (x<=5); }

int main() {
    std::function<bool(int)> func = leq_five;
    bool leq_five_v = func(5);
    std::cout << leq_five_v << " " << func(6) << std::endl;
}
```

### Virtual Functions

**Virtual functions** allow us to achieve runtime polymorphism. They are declared in a base class and can be overridden in derived classes. We can use an abstract base class with a pure virtual function for this purpose.

```cpp
#include <iostream>

struct Predicate {
    virtual bool operator()(int) const = 0;
};

struct LeqFive : public Predicate {
    bool operator()(int x) const override { return (x<=5); }
};

int main() {
    LeqFive filter_obj;
    bool leq_five_v = filter_obj(5);
    std::cout << leq_five_v << " " << filter_obj(6) << std::endl;
}
```

### Functors

**Functors** are objects that can be called as if they were functions. They are classes that provide an overloaded function call operator (`operator()`) and can hold state.

```cpp
struct Leq {
    int cmp;
    Leq(int init) : cmp(init) {}
    bool operator()(int x) const { return (x<=cmp); }
};

int main() {
    Leq leq_five(5);
    bool leq_five_v = leq_five(5);
    std::cout << leq_five_v << " " << leq_five(6) << std::endl;
}
```

Functors provide better optimization opportunities compared to function pointers. The C++ standard library provides predefined functors in the `<functional>` header like `std::plus`, `std::negate`, `std::greater`, and `std::less_equal`.

### Lambdas

**Lambdas** are anonymous functions that can be defined inline, providing a concise way to define and use functions without the need for a separate function declaration. The capture clause specifies what variables from the surrounding scope should be captured and made available inside the lambda body.

```cpp
int main() {
    auto sum = [](int a, int b) -> int {
        return a + b;
    };
    std::cout << sum(1,2) << std::endl;
}
```

A lambda's type is unique and its trailing return type is optional. Instead of storing a lambda in a variable, it can be evaluated directly.

Completely anonymous lambda:

```cpp
int main() {
    std::cout <<
    [](int a, int b) -> int {
        return a + b;
    }(1,2)
    << std::endl;
}
```

**Lambdas** can capture variables from the enclosing scope by copy `[=]` or by reference `[&]`. Individual variables can be captured by copy `[x]` or reference `[&x]`.

```cpp
int main() {
    int x = 2;
    auto x2 = [x] { return x * 2; } ();
    std::cout << x2 << std::endl;
}
```

Generic lambdas can accept arguments of different types. They use the auto type specifier in lambda parameters, enabling the lambda to deduce argument types at compile time.

Generic lambda:

```cpp
#include <iostream>

int main() {
    auto sum = [](auto a, auto b) {
        return a + b;
    };
    std::cout << sum(1,2.0) << std::endl;
}
```

Since C++20, generic lambdas can also have template parameters.

Generic lambda with explicit template parameters:

```cpp
#include <iostream>

int main() {
    auto sum = []<typename T, typename S>(T a, S b) {
        return a + b;
    };
    std::cout << sum(1,2.0) << std::endl;
}
```

Some algorithms in the STL can be customized by taking a callable as additional argument.

```cpp
struct X {
    int key;
    int value;
    X(int k) : key(k), value(-k) {};
};

int main() {
    std::vector<X> v = {1,4,3,2,7,6,5,8,9};
    auto compare = [](auto x1, auto x2){ return x1.key < x2.key; };
    std::sort(std::begin(v), std::end(v), compare);
    auto print = [](X const& xi){ std::cout <<"("<<xi.key<<","<<xi.value<<") "; };
    std::for_each(std::begin(v), std::end(v), print);
    std::cout << std::endl;
}
```

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional>

int main() {
    std::vector<int> v1 = {1,4,3,2,7};
    std::vector<int> v2 = {0,6,5,8,9};
    std::vector<int> res(5);
    std::transform(std::cbegin(v1), std::cend(v1), std::cbegin(v2),
    std::begin(res), std::minus<int>{});
    for (auto const& ri : res)
    std::cout << ri << ", ";
    std::cout << std::endl;
}
```

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

int main() {
    std::vector<int> v = {1,4,3,2,7,6,5,8,9};
    int condition_calls = 0;
    auto condition = [&condition_calls](auto xi){ ++condition_calls; return xi>5; };
    auto it = std::find_if(std::begin(v), std::end(v), condition);
    std::cout << *it << std::endl;
    std::cout << condition_calls << std::endl;
}
```

### Take aways
- Callables in C++ are objects that can be called as if they were functions.
- Lambdas are anonymous functions that can be defined inline.
- Generic lambdas allow lambdas to accept arguments of different types.
- Most of the algorithms in the STL are customizable by passing a callable to the function call.
